//SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

interface IDisputeMarketMinimal {
    // Basic info returns creator, respondent, title, description, category, priority, status
    function getDisputeBasicInfo(uint256 _disputeId)
        external
        view
        returns (
            address creator,
            address respondent,
            string memory title,
            string memory description,
            uint8 category,
            uint8 priority,
            uint8 status
        );

    // Results returns creatorVotes, respondentVotes, winner address
    function getDisputeResults(uint256 _disputeId)
        external
        view
        returns (uint256 creatorVotes, uint256 respondentVotes, address winner);

    // Timestamps returns creation, end, votingEnd (we use end as betting cutoff)
    function getDisputeTimestamps(uint256 _disputeId)
        external
        view
        returns (uint40 creationTime, uint40 endTime, uint40 votingEndTime);

    // Public getter generated by Solidity for public mapping disputeToNftToken
    function disputeToNftToken(uint256 disputeId) external view returns (uint256);

    // Standard ERC721 function available on DisputeMarket (it inherits ERC721)
    function ownerOf(uint256 tokenId) external view returns (address);
}

/**
 * @title PariMutuelBetting
 * @dev Pariâ€‘mutuel betting on DisputeMarket outcomes using KWN stablecoin.
 *      Outcome 0 = Creator wins, Outcome 1 = Respondent wins. Bets close at Dispute endTime.
 *      Upon resolution, winners split the losing pool minus fees, and the winning dispute NFT accrues a rake in KWN.
 */
contract PariMutuelBetting is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    // ====== Constants ======
    uint16 public constant MAX_BPS = 10_000; // 100%

    // DisputeMarket status enum indexes (mirrors DisputeStatus in DisputeMarket)
    // Pending=0, Active=1, UnderReview=2, Voting=3, Resolved=4
    uint8 private constant STATUS_RESOLVED = 4;

    // Outcomes
    uint8 public constant OUTCOME_CREATOR = 0;
    uint8 public constant OUTCOME_RESPONDENT = 1;
    uint8 public constant OUTCOME_TIE = 2;

    // ====== Immutable Config ======
    IERC20 public immutable KWN; // KWN stablecoin token
    IDisputeMarketMinimal public immutable market;

    // Protocol treasury and fee (bps of total pool)
    address public treasury;
    uint16 public protocolFeeBps; //  100 = 1%

    // Default rake to the winner NFT (bps of total pool), can be overridden per pool
    uint16 public defaultNftRakeBps; //  300 = 3%

    // Slash applied on tie/voided cases during refunds (bps of each refund)
    uint16 public tieSlashBps; //  100 = 1%, 0 = disabled

    // ====== Storage ======
    struct Pool {
        bool exists;
        bool resolved;
        bool voided; // set true if tie or invalid resolution
        uint16 nftRakeBps; // if 0, uses defaultNftRakeBps
        uint16 protocolFeeBpsOverride; // 0 = use global
        uint8 winningOutcome; // valid when resolved and not voided

        uint256 totalStaked; // sum of all sides
        uint256[3] stakedPerOutcome; // index 0: creator, 1: respondent, 2: tie

        // Values fixed at resolution time for deterministic claims
        uint256 payoutPool; // totalStaked - nftRake - protocolFee
        uint256 winnerSideTotal; // stakedPerOutcome[winningOutcome]

        // NFT accrual accounting: tokenId for the dispute winner NFT
        uint256 winnerNftTokenId; // filled at resolve
    }

    // disputeId => Pool
    mapping(uint256 => Pool) public pools;

    // disputeId => outcome => user => amount
    mapping(uint256 => mapping(uint8 => mapping(address => uint256))) public userStake;

    // ====== Events ======
    event PoolCreated(uint256 indexed disputeId, uint16 nftRakeBps, uint16 protocolFeeBps);
    event BetPlaced(uint256 indexed disputeId, address indexed user, uint8 indexed outcome, uint256 amount);
    event PoolResolved(
        uint256 indexed disputeId,
        uint8 indexed winningOutcome,
        uint256 payoutPool,
        uint256 nftRake,
        uint256 protocolFee,
        uint256 winnerNftTokenId
    );
    event PoolVoided(uint256 indexed disputeId);
    event Claimed(uint256 indexed disputeId, address indexed user, uint256 amount);
    event Refunded(uint256 indexed disputeId, address indexed user, uint256 amount);
    event NftWithdraw(uint256 indexed tokenId, address indexed to, uint256 amount);

    // Accrued KWN per Dispute NFT tokenId
    mapping(uint256 => uint256) public nftAccruedKWN;

    // ====== Constructor ======
    constructor(address _kwn, address _market, address _treasury) Ownable(msg.sender) {
        require(_kwn != address(0) && _market != address(0) && _treasury != address(0), "Invalid addresses");
        KWN = IERC20(_kwn);
        market = IDisputeMarketMinimal(_market);
        treasury = _treasury;
        // preset defaults
        protocolFeeBps = 100; // 1%
        defaultNftRakeBps = 300; // 3%
        tieSlashBps = 100; // 1% slash on void refunds
    }

    // ====== Admin ======
    function setTreasury(address _treasury) external onlyOwner {
        require(_treasury != address(0), "zero treasury");
        treasury = _treasury;
    }

    function setProtocolFeeBps(uint16 _bps) external onlyOwner {
        require(_bps <= MAX_BPS, "bps too high");
        protocolFeeBps = _bps;
    }

    function setDefaultNftRakeBps(uint16 _bps) external onlyOwner {
        require(_bps <= MAX_BPS, "bps too high");
        defaultNftRakeBps = _bps;
    }

    function setTieSlashBps(uint16 _bps) external onlyOwner {
        require(_bps <= MAX_BPS, "bps too high");
        tieSlashBps = _bps;
    }

    // Create pool for a dispute; optional overrides for fees
    function createPool(uint256 disputeId, uint16 nftRakeBpsOverride, uint16 protocolFeeBpsOverride) external  {
        require(!pools[disputeId].exists, "pool exists");
        // ensure dispute exists and is not resolved
        (, , , , , , uint8 status) = market.getDisputeBasicInfo(disputeId);
        require(status < STATUS_RESOLVED, "dispute resolved");

        pools[disputeId].exists = true;
        pools[disputeId].nftRakeBps = nftRakeBpsOverride; // 0 means use default
        pools[disputeId].protocolFeeBpsOverride = protocolFeeBpsOverride; // 0 means use global

        emit PoolCreated(
            disputeId,
            nftRakeBpsOverride == 0 ? defaultNftRakeBps : nftRakeBpsOverride,
            protocolFeeBpsOverride == 0 ? protocolFeeBps : protocolFeeBpsOverride
        );
    }

    // ====== Betting ======
    function bet(uint256 disputeId, uint8 outcome, uint256 amountKWN) external nonReentrant {
        require(amountKWN > 0, "amount=0");
        Pool storage p = pools[disputeId];
        require(p.exists, "no pool");
        require(outcome == OUTCOME_CREATOR || outcome == OUTCOME_RESPONDENT || outcome == OUTCOME_TIE, "bad outcome");

        // Ensure betting window is open: before Dispute endTime and not resolved
        (, , uint40 endTime, ) = _getTimes(disputeId);
        require(block.timestamp < endTime, "betting closed");
        require(!p.resolved && !p.voided, "pool finished");

        // Pull KWN and update accounting
        KWN.safeTransferFrom(msg.sender, address(this), amountKWN);
        p.totalStaked += amountKWN;
        p.stakedPerOutcome[outcome] += amountKWN;
        userStake[disputeId][outcome][msg.sender] += amountKWN;

        emit BetPlaced(disputeId, msg.sender, outcome, amountKWN);
    }

    // ====== Resolve and Claim ======
    function resolve(uint256 disputeId) external nonReentrant {
        Pool storage p = pools[disputeId];
        require(p.exists, "no pool");
        require(!p.resolved && !p.voided, "already finished");

        (address creator, address respondent, , , , , uint8 status) = market.getDisputeBasicInfo(disputeId);
        require(status == STATUS_RESOLVED, "not resolved on market");
        (, , address winner) = market.getDisputeResults(disputeId);

        // Determine winning outcome including tie
        uint8 winningOutcome;
        if (winner == creator) {
            winningOutcome = OUTCOME_CREATOR;
        } else if (winner == respondent) {
            winningOutcome = OUTCOME_RESPONDENT;
        } else {
            // DisputeMarket uses contract address to represent tie
            winningOutcome = OUTCOME_TIE;
        }
        uint256 winnerSideTotal = p.stakedPerOutcome[winningOutcome];
        // If no liquidity on winning side, void
        if (winnerSideTotal == 0) {
            p.voided = true;
            emit PoolVoided(disputeId);
            return;
        }

        uint16 nftBps = p.nftRakeBps == 0 ? defaultNftRakeBps : p.nftRakeBps;
        uint16 protoBps = p.protocolFeeBpsOverride == 0 ? protocolFeeBps : p.protocolFeeBpsOverride;
        require(uint256(nftBps) + uint256(protoBps) <= MAX_BPS, "fees too high");

        uint256 total = p.totalStaked;
        uint256 nftRake = (total * nftBps) / MAX_BPS;
        uint256 protoFee = (total * protoBps) / MAX_BPS;
        uint256 payoutPool = total - nftRake - protoFee;

        // Credit NFT accrual
        uint256 tokenId = market.disputeToNftToken(disputeId);
        p.winnerNftTokenId = tokenId;
        nftAccruedKWN[tokenId] += nftRake;

        // Transfer protocol fee
        if (protoFee > 0) {
            KWN.safeTransfer(treasury, protoFee);
        }

        p.resolved = true;
        p.winningOutcome = winningOutcome;
        p.payoutPool = payoutPool;
        p.winnerSideTotal = winnerSideTotal;

        emit PoolResolved(disputeId, winningOutcome, payoutPool, nftRake, protoFee, tokenId);
    }

    function claim(uint256 disputeId) external nonReentrant {
        Pool storage p = pools[disputeId];
        require(p.exists, "no pool");

        if (p.voided) {
            // refund both sides, optionally applying tie slash fee to treasury
            uint256 amount = userStake[disputeId][OUTCOME_CREATOR][msg.sender] +
                userStake[disputeId][OUTCOME_RESPONDENT][msg.sender];
            require(amount > 0, "nothing to refund");
            userStake[disputeId][OUTCOME_CREATOR][msg.sender] = 0;
            userStake[disputeId][OUTCOME_RESPONDENT][msg.sender] = 0;

            if (tieSlashBps > 0) {
                uint256 slash = (amount * tieSlashBps) / MAX_BPS;
                uint256 rebate = amount - slash;
                if (slash > 0) {
                    KWN.safeTransfer(treasury, slash);
                }
                KWN.safeTransfer(msg.sender, rebate);
                emit Refunded(disputeId, msg.sender, rebate);
            } else {
                KWN.safeTransfer(msg.sender, amount);
                emit Refunded(disputeId, msg.sender, amount);
            }
            return;
        }

        require(p.resolved, "not resolved");
        uint8 w = p.winningOutcome;
        uint256 stakeAmount = userStake[disputeId][w][msg.sender];
        require(stakeAmount > 0, "no winning stake");

        // zero first to prevent re-entrancy claim
        userStake[disputeId][w][msg.sender] = 0;
        uint256 payout = (stakeAmount * p.payoutPool) / p.winnerSideTotal;
        KWN.safeTransfer(msg.sender, payout);
        emit Claimed(disputeId, msg.sender, payout);
    }

    // ====== NFT Withdraw ======
    function withdrawNftAccrued(uint256 tokenId, address to) external nonReentrant {
        require(to != address(0), "bad to");
        // only NFT owner can withdraw
        require(market.ownerOf(tokenId) == msg.sender, "not nft owner");
        uint256 amount = nftAccruedKWN[tokenId];
        require(amount > 0, "nothing accrued");
        nftAccruedKWN[tokenId] = 0;
        KWN.safeTransfer(to, amount);
        emit NftWithdraw(tokenId, to, amount);
    }

    // ====== Views ======
    function previewPayout(uint256 disputeId, address account) external view returns (uint256 payout, bool ready) {
        Pool storage p = pools[disputeId];
        if (p.voided) {
            uint256 amount = userStake[disputeId][OUTCOME_CREATOR][account] +
                userStake[disputeId][OUTCOME_RESPONDENT][account];
            return (amount, true);
        }
        if (!p.resolved) return (0, false);
        uint256 stakeAmount = userStake[disputeId][p.winningOutcome][account];
        if (stakeAmount == 0) return (0, true);
        payout = (stakeAmount * p.payoutPool) / p.winnerSideTotal;
        return (payout, true);
    }

    function getPool(uint256 disputeId)
        external
        view
        returns (
            bool exists,
            bool resolved,
            bool voided,
            uint16 nftRakeBps,
            uint16 protocolFeeBpsOverride,
            uint8 winningOutcome,
            uint256 totalStaked,
            uint256 stakedCreator,
            uint256 stakedRespondent,
            uint256 payoutPool,
            uint256 winnerSideTotal,
            uint256 winnerNftTokenId
        )
    {
        Pool storage p = pools[disputeId];
        return (
            p.exists,
            p.resolved,
            p.voided,
            p.nftRakeBps,
            p.protocolFeeBpsOverride,
            p.winningOutcome,
            p.totalStaked,
            p.stakedPerOutcome[OUTCOME_CREATOR],
            p.stakedPerOutcome[OUTCOME_RESPONDENT],
            p.payoutPool,
            p.winnerSideTotal,
            p.winnerNftTokenId
        );
    }

    // ====== Internal helpers ======
    function _getTimes(uint256 disputeId) internal view returns (address creator, address respondent, uint40 endTime, uint40 votingEnd) {
        (creator, respondent, , , , , ) = market.getDisputeBasicInfo(disputeId);
        (, endTime, votingEnd) = market.getDisputeTimestamps(disputeId);
    }
}


